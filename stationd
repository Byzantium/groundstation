#!/usr/bin/env python
import os
import sys
import select
import time

from groundstation import logger
log = logger.getLogger("stationd")

from groundstation import settings

from groundstation.station import Station
from groundstation.broadcast_discoverer import BroadcastDiscoverer
from groundstation.broadcast_announcer import BroadcastAnnouncer
from groundstation.stream_listener import StreamListener
from groundstation.stream_client import StreamClient
from groundstation.node import Node
from groundstation.peer_socket import PeerSocket
from groundstation.sockets.socket_closed_exception import SocketClosedException
from groundstation.peer_socket_pool import PeerSocketPool
from groundstation.broadcast_events import new_broadcast_event, UnknownBroadcastEvent
from groundstation.broadcast_events.broadcast_ping import BroadcastPing

from os.path import expanduser

PORT = settings.PORT
BEACON_TIMEOUT = settings.BEACON_TIMEOUT

myself = Node()

station_path = expanduser("~/.groundstation")
station = Station(station_path)

discoverer = BroadcastDiscoverer(PORT)
announcer  = BroadcastAnnouncer(PORT)
listener   = StreamListener(PORT)
announcer.name = myself.name

sockets = [discoverer, listener]
peer_sockets = PeerSocketPool()

last_beacon = time.time() - BEACON_TIMEOUT # Gaurantee that we'll announce on the first run

def _read_sockets():
    read_sockets = []
    for i in sockets: read_sockets.append(i)
    for i in peer_sockets: read_sockets.append(i)
    return read_sockets

def _write_sockets():
    write_sockets = []
    for i in peer_sockets:
        if i.has_data_ready():
            write_sockets.append(i)
    return write_sockets

while True:
    if time.time() > (last_beacon + BEACON_TIMEOUT):
        last_beacon = time.time()
        announcer.ping()

    log.info("Blocking on sockets for up to %is" % (BEACON_TIMEOUT))
    (sread, swrite, sexc) = select.select(_read_sockets(), _write_sockets(), [], BEACON_TIMEOUT)
    log.info("Got %i read fds" % (len(sread)))
    log.info("Got %i write fds" % (len(swrite)))

    for i in sread:
        if i == discoverer:
            # TODO Return Event objects instead of raw data
            data, peer = discoverer.recv(settings.DEFAULT_BUFSIZE)
            try:
                event = new_broadcast_event(data)
            except UnknownBroadcastEvent:
                log.warning("Ooops got some weird event: %s" % (repr(data)))
            if isinstance(event, BroadcastPing):
                if event.payload == myself.uuid:
                    log.info("Discarding PING from myself")
                else:
                    log.info("Ping from %s" % str(peer))
                    if event.payload > myself.uuid:
                        # Peer's uuid is larger, we should connect and initiate sync
                        if peer[0] not in peer_sockets:
                            client = StreamClient(peer[0])
                            peer_sockets.append(client)
                            client.begin_handshake()
                    else:
                        # Peer's uuid is smaller, we should do nothing and await connection
                        log.info("Peer's uuid is smaller, awaiting connection")

        elif i == listener:
            peer = listener.accept()
            peer_sockets.append(peer)
        elif isinstance(i, PeerSocket) or isinstance(i, StreamClient):
            try:
                data = i.recv()
                log.info("got %s back from peer" % (repr(data)))
            except SocketClosedException:
                peer_sockets.remove(i)

    for i in swrite:
        if isinstance(i, PeerSocket):
            i.send()
        elif isinstance(i, StreamClient):
            i.send()

        # else: # Right now that's the only socket
