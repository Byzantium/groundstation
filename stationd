#!/usr/bin/env python
import os
import sys
import select
import time

from groundstation import logger
log = logger.getLogger("stationd")

from groundstation import settings

from groundstation.station import Station
from groundstation.sockets.broadcast_socket import BroadcastUnrouteable
from groundstation.broadcast_discoverer import BroadcastDiscoverer
from groundstation.broadcast_announcer import BroadcastAnnouncer
from groundstation.stream_listener import StreamListener
from groundstation.stream_client import StreamClient
from groundstation.node import Node
from groundstation.peer_socket import PeerSocket
from groundstation.sockets.socket_closed_exception import SocketClosedException
from groundstation.peer_socket_pool import PeerSocketPool
from groundstation.broadcast_events import new_broadcast_event, UnknownBroadcastEvent
from groundstation.broadcast_events.broadcast_ping import BroadcastPing
from groundstation.gizmo_factory import InvalidGizmoError

from os.path import expanduser

PORT = settings.PORT
BEACON_TIMEOUT = settings.BEACON_TIMEOUT

myself = Node()

station_path = expanduser("~/.groundstation")
station = Station(station_path, myself)

discoverer = BroadcastDiscoverer(PORT)
announcer  = BroadcastAnnouncer(PORT)
listener   = StreamListener(PORT)
announcer.name = myself.name

sockets = [discoverer, listener]
peer_sockets = PeerSocketPool()

def handle_discoverer_event(i):
    # TODO Return Event objects instead of raw data
    data, peer = discoverer.recv(settings.DEFAULT_BUFSIZE)
    try:
        event = new_broadcast_event(data)
    except UnknownBroadcastEvent:
        log.warning("Ooops got some weird event: %s" % (repr(data)))
    if isinstance(event, BroadcastPing):
        if event.payload == myself.uuid:
            log.info("Discarding PING from myself")
        #elif event.addr == me!
        else:
            log.info("Ping from %s" % str(peer))
            if event.payload > myself.uuid:
                # Peer's uuid is larger, we should connect and initiate sync
                if peer[0] not in peer_sockets:
                    # Ensure that they're in our object cache- we're updating it now
                    if not station.recently_queried(event.payload):
                        return StreamClient(peer[0])
            else:
                # Peer's uuid is smaller, we should do nothing and await connection
                log.info("Peer's uuid is smaller, awaiting connection")


def noop():
    pass


def handle_listener_event(i):
    return listener.accept(PeerSocket)


def handle_tcpnetwork_event(i):
    try:
        i.recv()
        while i.packet_queue:
            data = i.packet_queue.pop()
            gizmo = station.gizmo_factory.hydrate(data, i)
            assert gizmo is not None, "gizmo_factory returned None"
            gizmo.process()
    except SocketClosedException:
        peer_sockets.remove(i)
    except InvalidGizmoError:
        log.warn("Recieved invalid gizmo!")


def handle_iterators():
    station.handle_iters()


def handle_deferreds():
    station.handle_deferreds()


def handler_for(thing):
    if thing == discoverer:
        return handle_discoverer_event
    elif thing == listener:
        return handle_listener_event
    elif isinstance(thing, PeerSocket) or isinstance(thing, StreamClient):
        return handle_tcpnetwork_event
    else:
        raise KeyError


last_beacon = time.time() - BEACON_TIMEOUT # Gaurantee that we'll announce on the first run
def send_beacon():
    global last_beacon
    log.info("Current status :: Iterators: %i Deferreds: %i" %
            (len(station.iterators), len(station.deferreds)))
    if time.time() > (last_beacon + BEACON_TIMEOUT):
        last_beacon = time.time()
        try:
            announcer.ping()
        except BroadcastUnrouteable as e:
            log.fatal("broadcast was unrouteable")


def mainloop(r_fn, w_fn, e_fn, tick_fn):
    while True:
        tick_fn()
        (sread, swrite, sexc) = select.select(r_fn(), w_fn(), e_fn(), BEACON_TIMEOUT)
        log.info("Got %i fds. read: %s write: %i" % (len(sread) + len(swrite), len(sread), len(swrite)))

        for i in sread:
            if isinstance(i, PeerSocket) or isinstance(i, StreamClient):
                handle_tcpnetwork_event(i)
                break

            if i == discoverer:
                peer = handle_discoverer_event(i)
            elif i == listener:
                peer = handle_listener_event(i)
            else:
                raise Exception("Unhandled peer type: %s" % (repr(i)))

            if not peer:
                break

            pid = os.fork()
            if pid == 0:
                return peer
            elif pid < 0:
                log.fatal("fork failed, attempting to handle client in the master")
                peer_sockets.append(peer)
            elif pid > 0:
                log.info("successfully dispatched child: %i" % (pid))

        for i in swrite:
            if not (isinstance(i, PeerSocket) or isinstance(i, StreamClient)):
                log.warn("%s wants to do IO" % (type(i)))
                continue

            try:
                i.send()
            except SocketClosedException as e:
                log.info("Removing %s from clients" % (str(e.peer)))
                peer_sockets.remove(e.peer)

        if station.has_ready_iterators():
            handle_iterators()

        if station.has_ready_deferreds():
            handle_deferreds()


def _read_sockets():
    read_sockets = []
    for i in sockets: read_sockets.append(i)
    for i in peer_sockets: read_sockets.append(i)
    return read_sockets


def _write_sockets():
    write_sockets = []
    for i in peer_sockets:
        if i.has_data_ready():
            write_sockets.append(i)
    return write_sockets

if __name__ == "__main__":
    master_pid = os.getpid()
    peer = mainloop(_read_sockets, _write_sockets, lambda: [], send_beacon)
    assert os.getpid() != master_pid, \
        "Master process returned from mainloop"

    def child_read():
        return [peer]

    def child_write():
        v = []
        if peer.has_data_read():
            v.append(peer)
        return v

    log.info("Entering child mainloop")
    mainloop(child_read, child_write, lambda: [], noop)
    log.info("Child exited")
