#!/usr/bin/env python
import os
import sys
import select
import time

from groundstation import logger
log = logger.getLogger("stationd")

from groundstation.station import Station
from groundstation.broadcast_discoverer import BroadcastDiscoverer
from groundstation.broadcast_announcer import BroadcastAnnouncer
from groundstation.stream_listener import StreamListener
from groundstation.node import Node

from os.path import expanduser

PORT=1248
BEACON_TIMEOUT=5

myself = Node()

station_path = expanduser("~/.groundstation")
station = Station(station_path)

discoverer = BroadcastDiscoverer(PORT)
announcer  = BroadcastAnnouncer(PORT)
listener   = StreamListener(PORT)
announcer.name = myself.name

sockets = [discoverer, listener]

last_beacon = time.time() - BEACON_TIMEOUT # Gaurantee that we'll announce on the first run

while True:
    if time.time() > (last_beacon + BEACON_TIMEOUT):
        last_beacon = time.time()
        log.info("Sending PING on broadcast")
        announcer.ping()

    log.info("Blocking on sockets for up to %is" % (BEACON_TIMEOUT))
    (sread, write, sexc) = select.select(sockets, [], [], BEACON_TIMEOUT)
    log.info("Got %i ready fds" % len(sread))

    for i in sread:
        if i == discoverer:
            # TODO Return Event objects instead of raw data
            data, peer = discoverer.recv(1024)
            event_type, event_payload = data.split(" ", 1)
            if event_payload != "None" and event_payload != myself.name:
                log.info("Got %s from %s" % (data, repr(peer)))
            else:
                log.info("Discarding %s from myself" % (data))
        elif i == listener:
            (conn, address) = listener.accept()
            log.info("Accepted a connection from %s" % repr(address))
            # Close the connection since we have no handling yet.
            conn.close()


        # else: # Right now that's the only socket
